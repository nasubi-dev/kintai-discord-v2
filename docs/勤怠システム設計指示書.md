### **Discord 勤怠管理ボット 開発要件定義書 (v2.0 - 現在の実装)**

#### 1. プロジェクト概要

Discord のスラッシュコマンドを用いて勤怠を打刻し、その記録を Google スプレッドシートに月別のシートで管理する Bot を開発する。Bot のロジックは**Hono フレームワークを利用して**Cloudflare Workers 上で実装し、**Google Sheets API を直接呼び出し**てスプレッドシート操作を行う。

- **目的:** Discord 上での活動や作業時間を手軽に記録・管理する。
- **主要技術スタック:**
  - **ボットロジック:** Cloudflare Workers (TypeScript, Hono フレームワーク)
  - **スプレッドシート操作:** Google Sheets API（直接呼び出し）
  - **認証:** OAuth 2.0（ユーザー個別認証）
  - **データ暗号化:** AES-256-GCM
  - **データベース:** Google Spreadsheet + Cloudflare KV

---

#### 2. アーキテクチャ

現在の実装では Cloudflare Worker 内の処理が Hono によって構造化され、OAuth 2.0 認証と Google Sheets API の直接統合により、GAS を完全に廃止しています。

```
graph TD
    subgraph Discord
        User[Discord User] -- /start, /end, /setup --> API{Discord API}
    end

    subgraph "Cloudflare (Hono + KV)"
        API -- Webhook --> Worker[Hono App on Cloudflare]
        Worker <--> KV[Cloudflare KV Store]
        Worker <--> Crypto[AES-256-GCM 暗号化]
    end

    subgraph Google
        Worker -- OAuth 2.0 --> Auth[Google OAuth]
        Worker -- Google Sheets API --> Sheets[Google Spreadsheet]
    end

    Worker -- Ephemeral Msg etc. --> API
    API -- Bot Response --> User
```

1. **Hono App on Cloudflare:** Discord からの Webhook を単一のエンドポイントで受け取り、Hono の**ミドルウェア**でリクエスト署名を検証。**ルーティング**機能でコマンドを捌き、**Google Sheets API** を直接呼び出してデータを記録。
2. **Cloudflare KV Store:**
   - 勤怠の重複チェック用の高速ストレージ
   - OAuth トークンと設定の暗号化保存
   - サーバー毎の完全なデータ分離
3. **OAuth 2.0 認証:** ユーザー個別の Google 認証により、各サーバーが独自のスプレッドシートを管理
4. **暗号化:** AES-256-GCM による認証情報の安全な保存

---

#### 3. 機能要件

| ID        | 機能名                 | 詳細                                                                                                                   |
| :-------- | :--------------------- | :--------------------------------------------------------------------------------------------------------------------- |
| **FR-1**  | **勤怠開始**           | `/start` コマンドを実行すると、実行者の ID、チャンネル名、現在時刻を開始時刻としてスプレッドシートに記録する。         |
| **FR-2**  | **勤怠終了**           | `/end` コマンドを実行すると、該当する開始記録を探し、現在時刻を終了時刻として記録する。                                |
| **FR-3**  | **労働時間通知**       | `/end` コマンド成功時、その回の労働時間を計算し、コマンド実行者にのみ見えるメッセージ（Ephemeral Message）で通知する。 |
| **FR-4**  | **チャンネル名記録**   | コマンドが実行されたチャンネルの名前を「プロジェクト名」として記録する。                                               |
| **FR-5**  | **月別シート管理**     | 勤怠記録は、実行月ごとに分けられたシートに書き込む。シート名は `YYYY-MM` 形式（例: `2025-06`）とする。                 |
| **FR-6**  | **シート自動作成**     | 該当月のシートが存在しない場合、ヘッダー付きの新しいシートを自動で作成する。                                           |
| **FR-7**  | **自動セットアップ**   | `/setup` コマンドで OAuth 2.0 認証を行い、自動でスプレッドシートを作成・設定する。                                     |
| **FR-8**  | **重複打刻防止**       | KV ストレージを使用して高速な重複チェックを実行。既に開始している勤務がある場合は処理を中断する。                      |
| **FR-9**  | **自動クリーンアップ** | KV ストレージの勤怠記録は 24 時間の TTL で自動削除され、システムのメンテナンス負荷を軽減する。                         |
| **FR-10** | **設定管理**           | `/status` で現在の設定を確認、`/reset` で設定をリセットできる。                                                        |
| **FR-11** | **時刻指定**           | `/start 09:00` や `/end 18:30` のように、任意の時刻を指定して勤怠記録できる。                                          |

機能的な要件は、フレームワークの利用によって変更されません。FR-1 から FR-7 までの内容は前回の定義書と同様です。

---

#### 4. 詳細仕様

##### 4.1. データ構造 (Google Spreadsheet)

各月次シート（例: `2025-06`）は、以下の列を持つ必要があります。

| 列ヘッダー   | データ型 | 説明                                        |
| :----------- | :------- | :------------------------------------------ |
| `日付`       | string   | 勤怠開始日（YYYY-MM-DD 形式）               |
| `ユーザー名` | string   | コマンド実行者の Discord ユーザー名         |
| `ユーザーID` | string   | Discord ユーザー ID（ユーザー名変更に対応） |
| `開始時刻`   | string   | 勤務開始時刻（HH:MM 形式）                  |
| `終了時刻`   | string   | 勤務終了時刻（HH:MM 形式）                  |
| `休憩時間`   | string   | 休憩時間（現在は未実装、将来拡張用）        |
| `勤務時間`   | string   | 労働時間（H 時間 M 分 形式、自動計算）      |

##### 4.1.1. KV ストレージ構造

現在の実装では以下の 2 つの用途で KV ストレージを使用しています：

**1. 勤怠の重複チェック用**
| キー形式 | 値の構造 | TTL |
| :--------------------- | :------------------------------------------------------------------------------------------------ | :------ |
| `{userId}:{channelId}` | `{ startTime: string, username: string, channelName: string }` | 24 時間 |

**2. サーバー設定保存用（暗号化）**
| キー形式 | 値の構造 | TTL |
| :--------------------- | :------------------------------------------------------------------------------------------------ | :------ |
| `server:{guildId}` | 暗号化された設定データ（OAuth トークン、スプレッドシート情報等） | 永続 |

**例（勤怠記録）:**

- キー: `123456789012345678:987654321098765432`
- 値: `{ "startTime": "2025-06-25T09:00:00.000Z", "username": "user123", "channelName": "general" }`

**例（サーバー設定）:**

- キー: `server:123456789012345678`
- 値: 暗号化された JSON 文字列（復号化後: `{ spreadsheet_id, access_token, refresh_token, ... }`）

##### 4.2. コマンド仕様

現在実装されているコマンドの詳細仕様：

- **/setup**

  - **入力:** (引数なし)
  - **処理:**
    1. 管理者権限チェック
    2. 既存設定の確認
    3. OAuth 認証ガイド URL 生成
    4. セットアップページへの誘導
  - **応答 (本人にのみ見える):** セットアップガイドページの URL

- **/start**

  - **入力:** `time` (任意) - 指定時刻（HH:MM 形式）
  - **処理:**
    1. サーバー設定の存在確認
    2. **KV 重複チェック**: `{userId}:{channelId}` キーで既存記録を確認 (FR-8)
    3. 月次シートの存在確認・作成 (FR-6)
    4. 勤怠開始記録をスプレッドシートに追加 (FR-1)
    5. **KV 記録保存**: 重複チェック用の記録を KV に 24 時間 TTL で保存 (FR-9)
  - **応答 (全員に見える):** `✅ 勤務を開始しました。`

- **/end**

  - **入力:** `time` (任意) - 指定時刻（HH:MM 形式）
  - **処理:**
    1. サーバー設定の存在確認
    2. **KV 存在チェック**: `{userId}:{channelId}` キーで開始記録を確認
    3. スプレッドシート内の対応する開始記録を検索
    4. 終了時刻と勤務時間を計算・記録 (FR-2)
    5. **KV 記録削除**: 重複チェック用の記録を KV から削除
  - **応答 (全員に見える):** `✅ 勤務を終了しました。お疲れ様でした。**労働時間:** XX時間YY分` (FR-3)

- **/status**

  - **入力:** (引数なし)
  - **処理:**
    1. サーバー設定の取得
    2. Google Sheets API 接続テスト
    3. アクセストークンの有効性確認
  - **応答 (本人にのみ見える):** 設定状況と接続状態の詳細

- **/reset**
  - **入力:** (引数なし)
  - **処理:**
    1. 管理者権限チェック
    2. サーバー設定の完全削除
    3. KV ストレージからの設定削除
  - **応答 (本人にのみ見える):** 設定削除完了メッセージ

##### 4.3. エラーハンドリング

- **サーバー未設定:**

  - **場所:** 全コマンドで共通処理
  - **条件:** `/setup` 以外のコマンド実行時に、サーバー設定が存在しない場合
  - **応答 (本人にのみ見える):** `❌ サーバーが設定されていません。まず /setup コマンドで設定を行ってください。`

- **権限不足 (管理者限定コマンド):**

  - **場所:** `/setup`, `/reset` コマンド実行時
  - **条件:** 管理者権限を持たないユーザーが実行した場合
  - **応答 (本人にのみ見える):** `❌ このコマンドを実行するには管理者権限が必要です。`

- **重複設定防止:**

  - **場所:** `/setup` コマンド実行時
  - **条件:** 既にサーバー設定が存在する場合
  - **応答 (本人にのみ見える):** `⚠️ このサーバーは既に設定されています。設定をリセットする場合は /reset コマンドを使用してください。`

- **二重打刻防止 (FR-8):**

  - **場所:** `/start` コマンド実行時
  - **条件:** 同ユーザー・同チャンネルでの KV 記録が既に存在する場合
  - **応答 (本人にのみ見える):** `❌ 既に勤務が開始されています。先に /end コマンドで勤務を終了してください。`

- **未開始勤務終了防止:**

  - **場所:** `/end` コマンド実行時
  - **条件:** 同ユーザー・同チャンネルでの KV 記録が存在しない場合
  - **応答 (本人にのみ見える):** `❌ 開始されていない勤務を終了することはできません。先に /start コマンドを実行してください。`

- **Google Sheets API エラー:**

  - **場所:** スプレッドシート操作時
  - **条件:** トークン期限切れ、権限不足、ネットワークエラー等
  - **処理:** 自動トークンリフレッシュ、詳細エラーメッセージの提供

- **時刻フォーマットエラー:**
  - **場所:** `/start time:XX:XX`, `/end time:XX:XX` 実行時
  - **条件:** 無効な時刻形式が指定された場合
  - **応答 (本人にのみ見える):** `❌ 時刻の形式が正しくありません。HH:MM形式で入力してください（例: 09:00）`

---

#### 5. 現在の実装状況と技術詳細

##### 5.1. プロジェクト構成

```
src/
├── index.ts                  # Hono アプリケーションのエントリーポイント
├── types.ts                  # TypeScript 型定義
├── utils.ts                  # ユーティリティ関数（署名検証、時刻処理等）
├── oauth-service.ts          # OAuth 2.0 認証処理
├── server-config-service.ts  # サーバー設定管理
├── sheets-service.ts         # Google Sheets API 操作
├── discord-api-service.ts    # Discord API 操作
└── crypto-service.ts         # AES-256-GCM 暗号化処理
```

主要な開発コマンド：

- 開発サーバー: `bun run dev`
- デプロイ: `bun run deploy`
- 型チェック: `bun run cf-typegen`
- TypeScript コンパイル: `bun run tsc --noEmit`

##### 5.2. 基本的なコード構造 (`src/index.ts`)

```typescript
import { Hono } from "hono";
import { Bindings } from "./types";
import {
  InteractionType,
  InteractionResponseType,
  MessageFlags,
  APIInteraction,
} from "discord-api-types/v10";
import { verifyDiscordRequest, isTimestampValid } from "./utils";
import { DiscordApiService } from "./discord-api-service";
import { OAuthService } from "./oauth-service";
import { ServerConfigService } from "./server-config-service";
import { SheetsService } from "./sheets-service";

const app = new Hono<{ Bindings: Bindings }>();

// Discord インタラクション処理
app.post("/api/interactions", async (c) => {
  try {
    // 署名検証
    const signature = c.req.header("x-signature-ed25519");
    const timestamp = c.req.header("x-signature-timestamp");

    if (!signature || !timestamp || !isTimestampValid(timestamp)) {
      return c.json({ error: "Invalid timestamp" }, 401);
    }

    const rawBody = await c.req.text();
    const verificationRequest = new Request(c.req.url, {
      method: "POST",
      headers: c.req.header(),
      body: rawBody,
    });

    const isValidRequest = await verifyDiscordRequest(
      verificationRequest,
      c.env
    );
    if (!isValidRequest) {
      return c.json({ error: "Invalid request signature" }, 401);
    }

    const interaction: APIInteraction = JSON.parse(rawBody);

    // PING への応答
    if (interaction.type === InteractionType.Ping) {
      return c.json({ type: InteractionResponseType.Pong });
    }

    // アプリケーションコマンドの処理
    if (interaction.type === InteractionType.ApplicationCommand) {
      const commandName = interaction.data.name;

      // サービス初期化
      const discordApiService = new DiscordApiService(c.env);
      const oauthService = new OAuthService(c.env);
      const serverConfigService = new ServerConfigService(c.env);

      switch (commandName) {
        case "setup":
          // セットアップ処理
          break;
        case "start":
          // 勤務開始処理
          break;
        case "end":
          // 勤務終了処理
          break;
        case "status":
          // ステータス確認処理
          break;
        case "reset":
          // 設定リセット処理
          break;
      }
    }

    return c.json({ error: "Unknown interaction type" }, 400);
  } catch (error) {
    console.error("Error processing interaction:", error);
    return c.json({ error: "Internal server error" }, 500);
  }
});

// OAuth コールバック処理
app.get("/oauth/callback", async (c) => {
  const code = c.req.query("code");
  const state = c.req.query("state");

  if (!code || !state) {
    return c.html(generateErrorPage("認証パラメータが不正です"));
  }

  const oauthService = new OAuthService(c.env);
  const result = await oauthService.handleCallback(code, state);

  if (result.success && result.guildId) {
    const discordApiService = new DiscordApiService(c.env);
    await discordApiService.notifySetupComplete(
      result.guildId,
      result.spreadsheetUrl!
    );
    return c.html(generateSuccessPage());
  } else {
    return c.html(generateErrorPage(result.error || "設定に失敗しました"));
  }
});

export default app;
```

##### 5.3. セキュリティ実装

**署名検証 (`src/utils.ts`)**

```typescript
export async function verifyDiscordRequest(
  request: Request,
  env: Bindings
): Promise<boolean> {
  const signature = request.headers.get("x-signature-ed25519");
  const timestamp = request.headers.get("x-signature-timestamp");
  const body = await request.text();

  if (!signature || !timestamp) return false;

  const isValid = await crypto.subtle.verify(
    "Ed25519",
    await crypto.subtle.importKey(
      "raw",
      hexToArrayBuffer(env.DISCORD_PUBLIC_KEY),
      { name: "Ed25519", namedCurve: "Ed25519" },
      false,
      ["verify"]
    ),
    hexToArrayBuffer(signature),
    new TextEncoder().encode(timestamp + body)
  );

  return isValid;
}
```

**暗号化 (`src/crypto-service.ts`)**

```typescript
export class CryptoService {
  async encrypt(data: string): Promise<string> {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const keyBuffer = encoder.encode(this.encryptionKey);

    const key = await crypto.subtle.importKey(
      "raw",
      keyBuffer,
      { name: "AES-GCM" },
      false,
      ["encrypt"]
    );

    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      dataBuffer
    );

    const result = new Uint8Array(iv.length + encrypted.byteLength);
    result.set(iv);
    result.set(new Uint8Array(encrypted), iv.length);

    return btoa(String.fromCharCode(...result));
  }
}
```

##### 5.4. Google Sheets API 統合

**直接 API 呼び出し (`src/sheets-service.ts`)**

```typescript
export class SheetsService {
  async createKintaiSpreadsheet(
    guildId: string
  ): Promise<CreateSpreadsheetResult> {
    const createResponse = await fetch(
      "https://sheets.googleapis.com/v4/spreadsheets",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${this.accessToken}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          properties: {
            title: `勤怠管理_${guildId}_${
              new Date().toISOString().split("T")[0]
            }`,
          },
        }),
      }
    );

    const spreadsheet = await createResponse.json();
    await this.setupHeaders(spreadsheet.spreadsheetId);

    return {
      success: true,
      spreadsheetId: spreadsheet.spreadsheetId,
      spreadsheetUrl: `https://docs.google.com/spreadsheets/d/${spreadsheet.spreadsheetId}`,
    };
  }
}
```

この実装により、GAS を使用せずに Cloudflare Workers 上で完結した勤怠管理システムを実現しています。
const verificationRequest = new Request(c.req.url, {
method: "POST",
headers: {
"x-signature-ed25519": signature,
"x-signature-timestamp": timestamp,
"content-type": "application/json",
},
body: rawBody,
});

// Discord 署名を検証
const isValid = await verifyDiscordRequest(
verificationRequest,
c.env.DISCORD_PUBLIC_KEY
);

```

##### 5.4. ルーティングと処理

Discord からのインタラクションは、すべて `/api/interactions` への POST リクエストとして Hono アプリケーションで受け取ります。この単一のルート内で、受け取ったリクエストボディの `data.name` (コマンド名) によって処理を分岐させます。

##### 5.5. 環境変数の利用

Hono のコンテキストオブジェクト `c` を通じて、`wrangler.toml` に設定した環境変数に安全にアクセスできます。

TypeScript

```

const gasUrl = c.env.GAS_WEB_APP_URL;
const allowedChannels = c.env.ALLOWED_CHANNEL_IDS.split(',');

````

---

#### 6. 必要な環境変数

**Cloudflare Workers (`wrangler.jsonc`):**

```bash
# Discord Bot 設定
DISCORD_APPLICATION_ID=your_discord_application_id
DISCORD_TOKEN=your_discord_token
DISCORD_PUBLIC_KEY=your_discord_public_key

# 暗号化キー（32文字）
ENCRYPTION_KEY=your_32_character_encryption_key

# Google OAuth認証情報は各ユーザーが個別に設定するため不要
````

**KV Namespace 設定:**

| 設定項目  | 値                   | 説明                                        |
| :-------- | :------------------- | :------------------------------------------ |
| `binding` | `KINTAI_DISCORD_KV`  | TypeScript コードで参照するバインディング名 |
| `id`      | (作成時に生成される) | Cloudflare KV ネームスペースの実際の ID     |

環境変数の設定は `bunx wrangler secret put <KEY>` コマンドを使用します。

---

#### 7. まとめ

この要件定義書に基づく勤怠管理 Bot は、以下の特徴を持つ現代的なシステムとして実装されています：

**✅ 完了済み機能:**

- OAuth 2.0 による自動設定システム
- AES-256-GCM 暗号化によるセキュアなデータ保存
- Google Sheets API 直接統合
- Hono フレームワークによる効率的なリクエスト処理
- Discord 署名検証による不正リクエスト防止
- サーバー毎の完全なデータ分離

**🚀 技術的優位性:**

- GAS 依存の完全排除
- リアルタイムでの Google Sheets 操作
- スケーラブルな Cloudflare Workers アーキテクチャ
- 最新の TypeScript と Discord API v10 対応

この実装により、ユーザーは `/setup` コマンド一つで完全に自動化された勤怠管理システムを利用開始できます。
